/**
 * Created by cselvaraj on 2/10/14.
 */

'use strict';

var KEYS = {
    backspace: 8,
    tab: 9,
    enter: 13,
    escape: 27,
    space: 32,
    up: 38,
    down: 40,
    comma: 188
};
var searchbloxModule = angular.module('searchbloxModule', ['facetModule', 'ui.bootstrap', 'ngSanitize']);

/**
 * @ngdoc directive
 * @name customInput.directive:customInput
 *
 * @description
 * ngCustomInput is an Angular directive that renders an input box with autosuggestions
 * Used mbenford's example taken from JSFiddle. Also moved the functions from old code to here
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {boolean=true} addOnEnter Flag performs a search on pressing the ENTER key.
 *
 */
searchbloxModule.directive('custominput', ["$interpolate", function ($interpolate) {
    function loadOptions(scope, attrs) {
        function getStr(name, defaultValue) {
            return attrs[name] ? $interpolate(attrs[name])(scope.$parent) : defaultValue;
        }

        function getBool(name, defaultValue) {
            var value = getStr(name, null);
            return value ? value === 'true' : defaultValue;
        }

        scope.options = {
            addOnEnter: getBool('addOnEnter', true)
        };
    }


    return {
        restrict: 'A,E',
        scope: { searchParam: '=ngModel', onsearch: '='},
        replace: false,
        transclude: true,
        template: '<div class="ngCustomInput col-md-2 col-md-offset-3" style="width:70%;">' +
            ' <div class="input-group">' +
            '    <span class="input-group-addon"><i class="glyphicon glyphicon-search"></i></span>' +
            '    <input class="form-control" type="text"' +
            '           placeholder="search term"' +
            '           ng-model="searchParam"' +
            '           ng-change="newTagChange()">' +
            '    <span class="input-group-btn">' +
            '    <a data-toggle="dropdown" class="btn btn-primary dropdown-toggle" href="#">' +
            '        <i class="glyphicon glyphicon-cog"></i>' +
            '        <span class="caret"></span></a>' +
            '    <ul class="dropdown-menu">' +
            '        <li><a href data-ng-click="partialMatch()" >partial match</a></li>' +
            '        <li><a href data-ng-click="exactMatch()">exact match</a></li>' +
            '        <li><a href data-ng-click="fuzzyMatch()">fuzzy match</a></li>' +
            '        <li><a href data-ng-click="matchAll()">match all</a></li>' +
            '    </ul>' +
            '</span>' +
            ' </div>' +
            '<div ng-transclude></div>' +
            '</div>',
        controller: ["$scope", "$attrs", "$element", function ($scope, $attrs, $element) {

            loadOptions($scope, $attrs);
            // do search options
            $scope.partialMatch = function () {
                var newvals = $scope.searchParam.replace(/"/gi, '').replace(/\*/gi, '').replace(/\~/gi, '').split(' ');
                var newstring = "";
                for (var item in newvals) {
                    if (newvals[item].length > 0 && newvals[item] != ' ') {
                        if (newvals[item] == 'OR' || newvals[item] == 'AND') {
                            newstring += newvals[item] + ' ';
                        } else {
                            newstring += '*' + newvals[item] + '* ';
                        }
                    }
                }
                $scope.searchParam = newstring;
                $scope.onsearch();
            }

            $scope.fuzzyMatch = function () {
                var newvals = $scope.searchParam.replace(/"/gi, '').replace(/\*/gi, '').replace(/\~/gi, '').split(' ');
                var newstring = "";
                for (var item in newvals) {
                    if (newvals[item].length > 0 && newvals[item] != ' ') {
                        if (newvals[item] == 'OR' || newvals[item] == 'AND') {
                            newstring += newvals[item] + ' ';
                        } else {
                            newstring += newvals[item] + '~ ';
                        }
                    }
                }
                $scope.searchParam = newstring;
                $scope.onsearch();
            }
            $scope.exactMatch = function () {
                var newvals = $scope.searchParam.replace(/"/gi, '').replace(/\*/gi, '').replace(/\~/gi, '').split(' ');
                var newstring = "";
                for (var item in newvals) {
                    if (newvals[item].length > 0 && newvals[item] != ' ') {
                        if (newvals[item] == 'OR' || newvals[item] == 'AND') {
                            newstring += newvals[item] + ' ';
                        } else {
                            newstring += '' + newvals[item] + ' ';
                        }
                    }
                }
                $.trim(newstring, ' ');
                $scope.searchParam = "\"" + newstring + "\"";
                $scope.onsearch();

            }
            $scope.matchAll = function () {
                $scope.searchParam = $.trim($scope.searchParam.replace(/ OR /gi, ' '));
                $scope.searchParam = ($scope.searchParam.replace(/ /gi, ' AND '));
                $scope.doSearch();
            }
            $scope.matchAny = function () {
                $scope.searchParam = $.trim($scope.searchParam.replace(/ AND /gi, ' '));
                $scope.searchParam = $scope.searchParam.replace(/ /gi, ' OR ');
                $scope.searchParam.focus().trigger('keyup');
                $scope.onsearch();
            }

            $scope.newTagChange = angular.noop;

            this.getNewTagInput = function () {
                var input = $element.find('input');
                input.changeValue = function (value) {
                    $scope.searchParam = value;
                };

                input.change = function (handler) {
                    $scope.newTagChange = function () {
                        handler($scope.searchParam);
                    };
                };

                return input;
            };
        }],
        link: function (scope, element) {
            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace];
            var input = element.find('input');

            input.bind('keydown', function (e) {
                var key;

                if (hotkeys.indexOf(e.keyCode) === -1) {
                    return;
                }

                key = e.keyCode;
                if (key === KEYS.enter && scope.options.addOnEnter) {
                    scope.onsearch();
                }
            });

            element.find('div').bind('click', function () {
                input[0].focus();
            });
        }
    };
}]);

/**
 * @ngdoc directive
 * @name customInput.directive:autocomplete
 *
 * @description
 * Provides autocomplete support for the customInput directive.
 * Used mbenford's example taken from JSFiddle for autocomplete.
 * @param {expression} source Callback that will be called for every keystroke and will be provided with the current
 *                            input's value. Must return a promise.
 */
searchbloxModule.directive('autocomplete', ["$document", function ($document) {
    function SuggestionList(loadFn) {
        var self = {};

        self.reset = function () {
            self.items = [];
            self.visible = false;
            self.index = -1;
            self.selected = null;
        };
        self.show = function () {
            self.selected = null;
            self.visible = true;
        };
        self.hide = function () {
            self.visible = false;
        };
        self.load = function (text) {
            if (self.selected === text) {
                return;
            }

            loadFn(text).then(function (items) {
                self.items = items;
                if (items.length > 0) {
                    self.show();
                }
            });
        };
        self.selectNext = function () {
            self.select(++self.index);
        };
        self.selectPrior = function () {
            self.select(--self.index);
        };
        self.select = function (index) {
            if (index < 0) {
                index = self.items.length - 1;
            }
            else if (index >= self.items.length) {
                index = 0;
            }
            self.index = index;
            self.selected = self.items[index];
        };

        self.reset();

        return self;
    }

    return {
        restrict: 'A,E',
        require: '?^custominput',
        scope: { source: '&' },
        template: '<div class="autocomplete" ng-show="suggestionList.visible">' +
            '  <ul class="suggestions">' +
            '    <li class="suggestion" ng-repeat="item in suggestionList.items"' +
            '                           ng-class="{selected: item == suggestionList.selected}"' +
            '                           ng-click="addSuggestion()"' +
            '                           ng-mouseenter="suggestionList.select($index)">{{ item }}</li>' +
            '  </ul>' +
            '</div>',
        link: function (scope, element, attrs, custominput) {
            var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down];
            var suggestionList = new SuggestionList(scope.source());
            var input = custominput.getNewTagInput();

            scope.suggestionList = suggestionList;

            scope.addSuggestion = function () {
                var added = false;

                if (suggestionList.selected) {
                    input.changeValue(suggestionList.selected);
                    suggestionList.reset();
                    input[0].focus();

                    added = true;
                }
                return added;
            };

            input.change(function (value) {
                if (value) {
                    suggestionList.load(value);
                } else {
                    suggestionList.reset();
                }
            });

            input.bind('keydown', function (e) {
                var key, handled;

                if (hotkeys.indexOf(e.keyCode) === -1) {
                    return;
                }

                if (suggestionList.visible) {
                    key = e.keyCode;
                    handled = false;

                    if (key === KEYS.down) {
                        suggestionList.selectNext();
                        handled = true;
                    }
                    else if (key === KEYS.up) {
                        suggestionList.selectPrior();
                        handled = true;
                    }
                    else if (key === KEYS.escape) {
                        suggestionList.reset();
                        handled = true;
                    }
                    else if (key === KEYS.enter || key === KEYS.tab) {
                        handled = scope.addSuggestion();
                        if (!handled) {
                            suggestionList.reset();
                            scope.$apply();
                        }
                    }

                    if (handled) {
                        e.preventDefault();
                        scope.$apply();
                    }
                }
            });

            $document.bind('click', function () {
                if (suggestionList.visible) {
                    suggestionList.reset();
                    scope.$apply();
                }
            });
        }
    };
}]);

searchbloxModule.filter('trust', function ($sce) {
    return function (val) {
        return $sce.trustAsHtml(val);
    };
});

//SERVICE
searchbloxModule.service('searchbloxService', ['$rootScope', function ($rootScope) {

    var noffilters;
    this.facetFieldsMap = new Object();
    this.sortBtns = new Object();

    function isBlank(strValue) {
        return (!strValue || /^\s*$/.test(strValue));
    }

    /**
     * Function for reading facet.json file
     * */
    this.getFacetFields = function (facets) {
        var fields = "";
        var values = new Object();
        var urlParam = "";
        for (var i in facets) {

            fields = fields + '&facet.field=' + facets[i].field;
            if (facets[i].size !== undefined && facets[i].size !== null) {
                fields = fields + '&f.' + facets[i].field + '.size=' + facets[i].size;
            }
            values[facets[i].field] = new Object();//facets[i].display;
            values[facets[i].field]["display"] = facets[i].display;

            if (facets[i].range !== undefined && facets[i].range !== null) {
                for (var r in facets[i].range) {
                    urlParam = urlParam + '&f.' + facets[i].field + '.range=[' + facets[i].range[r]["from"] + 'TO' + facets[i].range[r]["to"] + ']';
                }
                values[facets[i].field]["range"] = facets[i].range;
            }

            if (facets[i].daterange !== undefined && facets[i].daterange !== null) {

                for (r in facets[i].daterange) {
                    urlParam = urlParam + '&f.' + facets[i].field + '.range=[' + moment().subtract(facets[i].daterange[r]["calendar"], facets[i].daterange[r]["value"]).format("YYYY-MM-DDTHH:mm:ss") + 'TO*]';
                }
                values[facets[i].field]["daterange"] = facets[i].daterange;
            }

        }

        fields = fields + urlParam;
        this.facetFieldsMap = values;
        return fields;
    }

    /**
     * Function for reading sort buttons from facet.json
     **/
    this.getSortBtns = function (sortBtns) {
        //var field = "";
        var values = new Object();
        for (var i in sortBtns) {
            //if(field == "") field = sortBtns[i].field;
            values[sortBtns[i].field] = new Object();
            values[sortBtns[i].field]["display"] = sortBtns[i].display;
            values[sortBtns[i].field]["sortVal"] = sortBtns[i].field;
        }

        this.sortBtns = values;
        // return field;
    }

    /**
     * Function to check if the sort value is valid
     */
    this.sortBtnExists = function (sortVal) {
        for (var i in this.sortBtns) {
            if (sortVal == i) return true;
        }
        return false;
    }

    // function for generating url
    this.getUrlParams = function (url, query, facet, xsl, facetFields, sortDir, sortVal, page, pageSize, rangeFilter, dateFacet, filterFields, matchAny) {
        var urlParam = url;

        if (typeof(query) !== "undefined" && query !== null) {
            if (matchAny.toUpperCase() === "ON") {
                //q_low=web+page&st=adv&q_all=&q_phr=&q_not=&oc=all
                urlParam = urlParam + "?q_low=" + queryStringForMatchAny(query) + "&st=adv&q_all=&q_phr=&q_not=&oc=all";
            } else {
                urlParam = urlParam + "?&query=" + encodeURIComponent(query);
            }

        }

        if (typeof(facet) !== "undefined" && facet !== null) {
            urlParam = urlParam + "&facet=" + facet;
        }

        if (typeof(xsl) !== "undefined" && xsl !== null) {
            urlParam = urlParam + "&xsl=" + xsl;
        }

        if (typeof( facetFields) !== "undefined" && facetFields !== null) {
            urlParam = urlParam + facetFields;
        }

        if (typeof( sortDir) !== "undefined" && sortDir !== null && (sortDir == "asc" || sortDir == "desc")) {
            urlParam = urlParam + "&sortdir=" + sortDir;
        } else {
            urlParam = urlParam + "&sortdir=desc";
        }

        if (typeof( sortVal) !== "undefined" && sortVal !== null && !isBlank(sortVal)) {
            urlParam = urlParam + "&sort=" + sortVal;
        }

        if (typeof( page) !== "undefined" && page !== null && !isNaN(page)) {
            urlParam = urlParam + "&page=" + page;
        }

        if (typeof( pageSize) !== "undefined" && pageSize !== null && !isNaN(pageSize)) {
            urlParam = urlParam + "&pagesize=" + pageSize;
        }

        if (typeof( rangeFilter) !== "undefined" && rangeFilter !== null && !isBlank(rangeFilter)) {
            urlParam = urlParam + rangeFilter;
        }


        if (typeof( filterFields) !== "undefined" && filterFields !== null && !isBlank(filterFields)) {
            urlParam = urlParam + filterFields;
        }

        return urlParam;
    }

    function queryStringForMatchAny(queryString) {
        queryString = queryString.replace(/^\s+|\s+$/g, '').split(/[ ]+/).join('+');
        return queryString;
    }

    function startsWith(str, prefix) {
        return str.lastIndexOf(prefix, 0) === 0;
    }

    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length) !== -1;
    }

    // retrieves the auto suggestions
    this.parseAutoSuggestion = function (dataobj) {
        var suggestions = [];
        for (var i in dataobj[0]) {
            var value = dataobj[0][i];
            suggestions.push(value);
        }

        return suggestions;
    }

    function getParam(paramName, urlString) {
        paramName = paramName.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regexS = "[\\?&]" + paramName + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(urlString);
        if (results == null) {
            return "";
        }
        else {
            return results[1];
        }
    }

    this.parseLinks = function (dataobj, facetFieldsMap) {
        var resultobj = new Object();
        // resultobj["npages"] = new Array();
        resultobj["pages"] = new Array();
        resultobj["sort"] = new Array();
        if (typeof(dataobj.links) !== "undefined" && typeof(dataobj.links.link) !== "undefined") {
            for (var item in dataobj.links.link) {
                if (dataobj.links.link[item] !== "undefined" && dataobj.links.link[item] != null
                    && (dataobj.links.link[item]["@page"] === "date"
                    || dataobj.links.link[item]["@page"] === "alpha"
                    || dataobj.links.link[item]["@page"] === "relevance")) {
                    resultobj["sort"].push(dataobj.links.link[item]);
                } else {
                    var linkobj = new Object();
                    linkobj['pageName'] = dataobj.links.link[item]["@page"];
                    linkobj['pageNo'] = getParam('page', dataobj.links.link[item]["@url"]);
                    linkobj['url'] = dataobj.links.link[item]["@url"]
                    resultobj["pages"].push(linkobj);
                    //resultobj["pages"].push(dataobj.links.link[item]);
                }

            }
        }
        return resultobj;
    }

    // Moved this functions from old code to here to perform search
    // read the result object and return useful vals depending on if ES or SOLR
    // returns an object that contains things like ["data"] and ["facets"]
    this.parseResults = function (dataobj, facetFieldsMap) {
        var resultobj = new Object();
        resultobj["records"] = new Array();
        resultobj["start"] = "";
        resultobj["found"] = "";
        if (typeof(dataobj.results) !== "undefined" && typeof(dataobj.results.result) !== "undefined") {
            for (var item in dataobj.results.result) {
                if (item == "@no") {
                    resultobj["records"].push(dataobj.results.result);
                    resultobj["found"] = dataobj.results['@hits'];
                    break;
                }
                resultobj["records"].push(dataobj.results.result[item]);
                resultobj["found"] = dataobj.results['@hits'];
            }
        }
        if (typeof(dataobj.facets) !== "undefined") {
            if (dataobj.facets) {
                resultobj["facets"] = new Object();
                if (dataobj.facets.facet) {
                    var fname = "";
                    var count = "";
                    var facetsobj = new Object();
                    for (var item in dataobj.facets.facet) {
                        var values = new Object();
                        if (item == "@name")
                            fname = dataobj.facets.facet[item];
                        else if (item == "@count")
                            count = dataobj.facets.facet[item];
                        else if (item == "int") {
                            for (var thing in dataobj.facets.facet[item]) {
                                values[thing] = dataobj.facets.facet[item][thing];
                            }
                            facetsobj[fname] = new Object();
                            facetsobj['name'] = fname;
                            facetsobj[fname] = [count, values];
                        }
                    }
                    resultobj["facets"][0] = facetsobj;
                    this.noffilters = 1;
                }
                else {
                    var n = 0;
                    for (n in dataobj.facets) {
                        var fname = "";
                        var count = "";
                        var facetsobj = new Object();
                        for (var item in dataobj.facets[n]) {
                            var values = new Object();
                            if (item == "@name") {
                                fname = dataobj.facets[n][item];

                                if (fname === "lastmodified")//|| fname==="size"
                                {
                                    facetsobj[fname] = new Object();
                                    //alert(JSON.stringify(dataobj.facets[n]['int']));
                                    for (var t1 in dataobj.facets[n]['int']) {
                                        var data = new Array();
                                        data[0] = dataobj.facets[n]['int'][t1]['@from'];
                                        data[1] = dataobj.facets[n]['int'][t1]['@to'];
                                        data[2] = dataobj.facets[n]['int'][t1]['#text'];
                                        //data[3]="hello-value";
                                        facetsobj[fname][t1] = data;
                                    }
                                    //alert(JSON.stringify(facetsobj[fname]));
                                }
                            }
                            else if (item == "@count")
                                count = dataobj.facets[n][item];
                            else if (item == "int") {
                                for (var thing in dataobj.facets[n][item]) {
                                    if (thing == '@name') {
                                        values['0'] = dataobj.facets[n]['int'];
                                        break;
                                    }

                                    var filterRange = facetFieldsMap[fname]["range"];
                                    var filterDateRange = facetFieldsMap[fname]["daterange"];
                                    // Handle  range logic
                                    if (filterRange !== null && filterRange !== undefined) {
                                        var valueObject = dataobj.facets[n][item][thing];
                                        // check if this fname is a range field
                                        // handle range field
                                        for (var r in filterRange) {
                                            if (filterRange[r]["from"] === valueObject["@from"] && filterRange[r]["to"] === valueObject["@to"]) {
                                                valueObject["@name"] = filterRange[r]["name"];
                                                break;
                                            }
                                        }
                                        values[thing] = valueObject;
                                    }
                                    // Handle date range logic
                                    else if (filterDateRange !== null && filterDateRange !== undefined) {
                                        var valueObject = dataobj.facets[n][item][thing];
                                        // check if this fname is a range field
                                        // handle range field
                                        for (r in filterDateRange) {
                                            var dateValue = moment().subtract(filterDateRange[r]["calendar"], filterDateRange[r]["value"]).format("YYYY-MM-DD")
                                            if (startsWith(valueObject["@from"], dateValue)) {
                                                valueObject["@name"] = filterDateRange[r]["name"];
                                                valueObject["@calendar"] = filterDateRange[r]["calendar"];
                                                valueObject["@value"] = filterDateRange[r]["value"];
                                                break;
                                            }
                                        }
                                        values[thing] = valueObject;
                                    }
                                    else {
                                        values[thing] = dataobj.facets[n][item][thing];
                                    }
                                }
                                facetsobj[fname] = new Object();
                                facetsobj['name'] = fname;
                                facetsobj[fname] = [count, values];
                            }
                        }
                        resultobj["facets"][n] = facetsobj;
                    }
                    this.noffilters = n;
                }
            }
        }
        return resultobj;
    }
}]);

// FACTORY
searchbloxModule.factory('searchbloxFactory', ['$rootScope', '$http', function ($rootScope, $http) {
    var searchFactory = new Object();
    searchFactory.getResponseData = function (urlParams) {
        var promise = $http.get(urlParams).success(function (data, status) {
            return data;
        }).error(function (data, status) {
                return status;
            });
        return promise;

    };
    return searchFactory;
}]);

// CONTROLLER
searchbloxModule.controller('SearchBloxController', ['$rootScope', '$scope', '$http', '$location', 'searchbloxService', 'searchbloxFactory', 'facetFactory', '$q', '$timeout', '$sce',
    function ($rootScope, $scope, $http, $location, searchbloxService, searchbloxFactory, facetFactory, $q, $timeout, $sce) {// 'autoCompleteFactory',

        var searchUrl = '../servlet/SearchServlet';
        var autoSuggestUrl = '../servlet/AutoSuggest';
        var reportServletUrl = '../servlet/ReportServlet';

        // Hard coded these values. This needs to be dynamic
        var facet = 'on';
        var xsl = "json";
        var facetFields = "";
        var dateFacet = "";

        $scope.rangeFilter = "";
        $scope.filterFields = "";
        $scope.selectedItems = [];
        $scope.sortDir = "desc";
        $scope.sortVal = "";
        $scope.from = 0;
        $scope.page = 1;
        $scope.prevPage = 1;
        $scope.pageSize = 10;
        $scope.noOfSuggests = 5;
        $scope.showAutoSuggest = true;

        $scope.paginationHtml = "";
        $scope.tagHtml = "";
        $scope.topHtml = "";
        $scope.startedSearch = false;


        // load autosuggest items
        $scope.loadItems = function (term) {
            var autoSuggestData = $q.defer();
            searchbloxFactory.getResponseData(autoSuggestUrl + '?limit=' + $scope.noOfSuggests + '&q=' + term).then(function (suggestionResults) {
                var suggtns = searchbloxService.parseAutoSuggestion(suggestionResults.data);
                $scope.timer = $timeout(function () {
                    autoSuggestData.resolve(suggtns);
                }, 10);
            });
            return autoSuggestData.promise;

        };

        // Search function
        $scope.doSearch = function () {
            facetFactory.get().$promise.then(function (data) {
                if (data !== null) {
                    $scope.startedSearch = true;
                    facetFields = searchbloxService.getFacetFields(data.facets);
                    if (typeof($scope.sortVal) == "undefined" || $scope.sortVal == null || $scope.sortVal.trim() == "" || !searchbloxService.sortBtnExists($scope.sortVal.trim())) {
                        searchbloxService.getSortBtns(data.sortBtns);
                    }

                    console.log("MATCH----" + $scope.sortVal);

                    var urlParams = searchbloxService.getUrlParams(searchUrl, $scope.query, facet, xsl, facetFields,
                        $scope.sortDir, $scope.sortVal, $scope.page, $scope.pageSize, $scope.rangeFilter, dateFacet, $scope.filterFields, data.matchAny);
                    searchbloxFactory.getResponseData(urlParams).then(function (searchResults) {
                        $scope.facetMap = searchbloxService.facetFieldsMap;
                        $scope.parsedSearchResults = searchbloxService.parseResults(searchResults.data, $scope.facetMap);
                        console.log($scope.parsedSearchResults.found.type)
                        $scope.sortBtns = searchbloxService.sortBtns;
                        $scope.parsedLinks = searchbloxService.parseLinks(searchResults.data, $scope.facetMap);
                        // $scope.getTopClicked();
                        //$scope.getTagCloud();
                        $scope.startedSearch = true;
                    });
                }
            });
        }
        
        // result url generator
        $scope.getUrl = function(result){
        	console.log(result);
        	if(result.url.startsWith('db')){
        		var temp = '../servlet/DBServlet?col=' + result.col + '&id=' + result.uid;
        		return temp;
        	}
        	else if(result.uid.split(':')[0] == 'file'){
        		var temp = '../servlet/FileServlet?url=' + result.url + '&col=' + result.col;

        		if(result.href.startsWith('http')){
        			return result.url;
        		}
        		else{
        			return temp;
        		}
        	}
        	else if(result.url.split(':')[0] == 'eml'){
        		var temp = '../servlet/EmailViewer?url=' + result.uid + '&col=' + result.col;
        		return temp;
        	}
        	else{
            	return result.url;
        	}
        }

        // toggleAutoSuggest
        $scope.toggleAutoSuggest = function () {
            $scope.showAutoSuggest = !$scope.showAutoSuggest;
        }

        // Sort function
        $scope.doSort = function (sortVal) {
            $scope.sortVal = sortVal;
            $scope.doSearch();
        }

        // Sort function
        $scope.doDirector = function (direction) {
            $scope.sortDir = direction;
            $scope.doSearch();
        }

        // Get last modified formatted
        $scope.getLastModified = function (lastmodified) {
            return moment(lastmodified).format("MMMM Do YYYY, h:mm:ss a");
        }

        // get pagination
//        $scope.getPagination = function(){
//        	var metaTmpl = ' \
//                <div> \
//                  <ul class="pagination" style="float:left;padding:16px;"> \
//                    <li class="prev"><a href data-ng-click="getPrevPage(\'{{decrement_text}}\')">{{decrement_text}}</a></li> \
//                    <li class="active"><a>{{from}} &ndash; {{to}} of {{total}}</a></li> \
//                    <li class="next"><a href data-ng-click="getNextPage(\'{{increment_text}}\')">{{increment_text}}</a></li> \
//                  </ul> \
//                </div> \
//                ';
//
//        	var from = $scope.from + 1;
//            var size = $scope.pageSize;
//            !size ? size = 10 : "";
//            var to = $scope.from + size;
//            var found = $scope.parsedSearchResults.found;
//            found < to ? to = found : "";
//            var meta = metaTmpl.replace(/{{from}}/g, from);
//            meta = meta.replace(/{{to}}/g, to);
//            meta = meta.replace(/{{total}}/g, found);
//            from < size ? (meta = meta.replace(/{{decrement_text}}/g, "..")) : (meta = meta.replace(/{{decrement_text}}/g, "&laquo; back")) ;
//            $scope.parsedSearchResults.found <= to ? (meta = meta.replace(/{{increment_text}}/g, "..")) : (meta = meta.replace(/{{increment_text}}/g, "next &raquo;")) ;
//            $scope.paginationHtml = $sce.trustAsHtml(meta);
//        }

        // get tagcloud
        $scope.getTagCloud = function () {
            var taghtml = "<h3>Most Used Tags</h3></br><div id='facettagcloud'>";
            if ($scope.parsedSearchResults.facets != undefined && $scope.parsedSearchResults.facets != null && $scope.parsedSearchResults.facets[2].keywords != undefined && $scope.parsedSearchResults.facets[2].keywords != null)
                for (var a in $scope.parsedSearchResults.facets[2].keywords[1]) {
                    var value = $scope.parsedSearchResults.facets[2].keywords[1][a];
                    taghtml += "<a href='index.html?query=" + value['@name'] + "' tagrel='" + value['#text'] + "'>" + value['@name'] + " </a>";
                }
            taghtml += "</div>";
            $scope.tagHtml = $sce.trustAsHtml(taghtml);
            var list = document.getElementById("facettagcloud");
            if (list != undefined && list.childNodes.length > 0) {
                shuffleNodes(list);
                $.fn.tagcloud.defaults = {
                    size: {start: 14, end: 18, unit: 'pt'},
                    color: {start: '#cde', end: '#f52'}
                };
                $(function () {
                    $('#facettagcloud a').tagcloud();
                });
            }
        }

        // get top clicked function
        $scope.getTopClicked = function () {
            searchbloxFactory.getResponseData(reportServletUrl + '?&gettopclicks=yes&nodocs=5&query=' + $scope.query).then(function (topClickedResults) {
                topClickedResults = topClickedResults.data;
                var temphtml = "<h3>Most Viewed</h3></br>";
                if (topClickedResults != "nodocs" && topClickedResults != "queryerror" && topClickedResults != "")
                    for (var x in topClickedResults)
                        for (var y in topClickedResults[x])
                            temphtml += topClickedResults[x][y];
                if (topClickedResults != "nodocs" && topClickedResults != "queryerror" && topClickedResults != "")
                    $scope.topHtml = $sce.trustAsHtml(temphtml);
            });
        }

        // adjust how many results are shown
        $scope.howmany = function () {
            var newhowmany = prompt('Currently displaying ' + $scope.pageSize + ' results per page. How many would you like instead?');
            if (newhowmany) {
                $scope.pageSize = parseInt(newhowmany);
                $scope.from = 0;
                $scope.dosearch();
            }
        }

        // adjust how many suggestions are shown
        var howmanynofsuggest = function () {
            var newhowmany = prompt('Currently displaying ' + $scope.noOfSuggests + ' suggestions per page. How many would you like instead?');
            if (newhowmany) {
                $scope.noOfSuggests = parseInt(newhowmany);
                $scope.from = 0;
                $scope.dosearch();
            }
        }

        // Function for search by filter.
        $scope.doSearchByFilter = function (filter, facetName) {
            $scope.page = 1;
            var filters = "";
            var filterName = filter['@name'];
            var filterRangeFrom = filter['@from'];
            var filterRangeTo = filter['@to'];
            var filterRangeCalendar = filter['@calendar'];
            var filterRangeValue = filter['@value'];
            var hasFilter = false;
            for (var i = 0, l = $scope.selectedItems.length; i < l; i++) { // for(var obj in $scope.selectedItems){
                var obj = $scope.selectedItems[i];
                if (obj['filterRangeFrom'] !== undefined && obj['filterRangeTo'] !== undefined) {
                    if ((obj['filterName'] === filterName) && (obj['facetName'] === facetName)
                        && obj['filterRangeFrom'] === filterRangeFrom
                        && obj['filterRangeTo'] === filterRangeTo
                        ) {
                        hasFilter = true;
                    }
                    else {
                        filters = filters + '&f.' + obj['facetName'] + '.filter=[' + obj['filterRangeFrom'] + 'TO' + obj['filterRangeTo'] + ']';
                    }
                }
                else if (obj['filterRangeCalendar'] !== undefined && obj['filterRangeValue'] !== undefined) {
                    if ((obj['filterName'] === filterName) && (obj['facetName'] === facetName)
                        && obj['filterRangeCalendar'] === filterRangeCalendar
                        && obj['filterRangeValue'] === filterRangeValue
                        ) {
                        hasFilter = true;
                    }
                    else {
                        filters = filters + '&f.' + obj['facetName'] + '.filter=[' + moment().subtract(obj['filterRangeCalendar'], obj['filterRangeValue']).format("YYYY-MM-DDTHH:mm:ss") + 'TO*]';
                    }
                }
                else {
                    if ((obj['filterName'] === filterName) && (obj['facetName'] === facetName)) {
                        hasFilter = true;
                    }
                    else {
                        filters = filters + "&f." + obj['facetName'] + ".filter=" + obj['filterName'];
                    }
                }
            }

            if (!hasFilter) {
                var new_object = new Object();
                if (filterRangeFrom !== undefined && filterRangeTo !== undefined) {
                    $scope.filterFields = filters + '&f.' + facetName + '.filter=[' + filterRangeFrom + 'TO' + filterRangeTo + ']';
                }
                else if (filterRangeCalendar !== undefined && filterRangeValue !== undefined) {
                    $scope.filterFields = filters + '&f.' + facetName + '.filter=[' + moment().subtract(filterRangeCalendar, filterRangeValue).format("YYYY-MM-DDTHH:mm:ss") + 'TO*]';
                }
                else {
                    $scope.filterFields = filters + "&f." + facetName + ".filter=" + filterName;
                }
                new_object["id"] = $scope.selectedItems.size;
                new_object['filterName'] = filterName;
                new_object['facetName'] = facetName;
                new_object['filterRangeFrom'] = filterRangeFrom;
                new_object['filterRangeTo'] = filterRangeTo;
                new_object['filterRangeCalendar'] = filterRangeCalendar;
                new_object['filterRangeValue'] = filterRangeValue;
                new_object['pageNo'] = $scope.prevPage;
                $scope.prevPage = $scope.page;
                //it's up to you how you want to structure the new_object.
                $scope.showInput = true;
                $scope.selectedItems.push(new_object);
            }

            $scope.doSearch();
        }

        // Function for removing filter
        $scope.removeItem = function (index) {
            var selected_object = $scope.selectedItems[index];
            $scope.page = selected_object['pageNo']
            $scope.selectedItems.splice(index, 1);
            var filters = "";
            for (var i = 0, l = $scope.selectedItems.length; i < l; i++) { // for(var obj in $scope.selectedItems){
                var obj = $scope.selectedItems[i];
                if (obj['filterRangeFrom'] !== undefined && obj['filterRangeTo'] !== undefined) {
                    filters = filters + '&f.' + obj['facetName'] + '.filter=[' + obj['filterRangeFrom'] + 'TO' + obj['filterRangeTo'] + ']';
                }
                else if (obj['filterRangeCalendar'] !== undefined && obj['filterRangeValue'] !== undefined) {
                    filters = filters + '&f.' + obj['facetName'] + '.filter=[' + moment().subtract(obj['filterRangeCalendar'], obj['filterRangeValue']).format("YYYY-MM-DDTHH:mm:ss") + 'TO*]';
                }
                else {
                    filters = filters + "&f." + obj['facetName'] + ".filter=" + obj['filterName'];
                }
                // console.log("Remove Item In loop " + obj['filterName'] + " -- " + obj['facetName']);
            }
            $scope.filterFields = filters;
            $scope.doSearch();
        }

        // Function for fetch page results.
        $scope.fetchPage = function (pageNo) {
            $scope.page = pageNo;
            $scope.prevPage = pageNo;
            $scope.doSearch();
//        	var urlParams = searchbloxService.getUrlParams(searchUrl, $scope.query, facet, xsl, facetFields,
//            		$scope.sortDir, $scope.sortVal, $scope.page, $scope.pageSize, $scope.rangeFilter, dateFacet, $scope.filterFields);
//        	console.log(urlParams)
//            searchbloxFactory.getResponseData(urlParams).then(function (searchResults) {
//                $scope.facetMap = searchbloxService.facetFieldsMap;
//                $scope.parsedSearchResults = searchbloxService.parseResults(searchResults.data, $scope.facetMap);
//                console.log($scope.parsedSearchResults.found.type)
//                $scope.sortBtns = searchbloxService.sortBtns;
//                $scope.parsedLinks = searchbloxService.parseLinks(searchResults.data, $scope.facetMap);
//                $scope.getTopClicked();
//                $scope.getTagCloud();
//            });
        }

        $scope.formatData = function (highlightObj) {
            if (!angular.isArray(highlightObj))
                return [highlightObj];
            else
                return highlightObj;
        }
    }]);

